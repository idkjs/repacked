// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var $$Map = require("bs-platform/lib/js/map.js");
var List = require("bs-platform/lib/js/list.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Queue = require("bs-platform/lib/js/queue.js");
var Printf = require("bs-platform/lib/js/printf.js");
var Random = require("bs-platform/lib/js/random.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Printexc = require("bs-platform/lib/js/printexc.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var CamlinternalLazy = require("bs-platform/lib/js/camlinternalLazy.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");
var LwtDllist$Repacked = require("./LwtDllist.bs.js");

var Empty = /* @__PURE__ */Caml_exceptions.create("Lwt-Repacked.LwtSeq.Empty");

function get(node) {
  return node.node_data;
}

function set(node, data) {
  node.node_data = data;
  
}

function remove(node) {
  if (node.node_active) {
    node.node_active = false;
    node.prev.next = node.next;
    node.next.prev = node.prev;
    return ;
  }
  
}

function create(param) {
  var seq = {};
  seq.prev = seq;
  seq.next = seq;
  return seq;
}

function clear(seq) {
  seq.prev = seq;
  seq.next = seq;
  
}

function is_empty(seq) {
  return seq.next === seq;
}

function length(seq) {
  var _curr = seq.next;
  var _len = 0;
  while(true) {
    var len = _len;
    var curr = _curr;
    if (curr === seq) {
      return len;
    }
    _len = len + 1 | 0;
    _curr = curr.node_next;
    continue ;
  };
}

function add_l(data, seq) {
  var node = {
    node_prev: seq,
    node_next: seq.next,
    node_data: data,
    node_active: true
  };
  seq.next.prev = node;
  seq.next = node;
  return node;
}

function add_r(data, seq) {
  var node = {
    node_prev: seq.prev,
    node_next: seq,
    node_data: data,
    node_active: true
  };
  seq.prev.next = node;
  seq.prev = node;
  return node;
}

function take_l(seq) {
  if (seq.next === seq) {
    throw {
          RE_EXN_ID: Empty,
          Error: new Error()
        };
  }
  var node = seq.next;
  remove(node);
  return node.node_data;
}

function take_r(seq) {
  if (seq.next === seq) {
    throw {
          RE_EXN_ID: Empty,
          Error: new Error()
        };
  }
  var node = seq.prev;
  remove(node);
  return node.node_data;
}

function take_opt_l(seq) {
  if (seq.next === seq) {
    return ;
  }
  var node = seq.next;
  remove(node);
  return Caml_option.some(node.node_data);
}

function take_opt_r(seq) {
  if (seq.next === seq) {
    return ;
  }
  var node = seq.prev;
  remove(node);
  return Caml_option.some(node.node_data);
}

function transfer_l(s1, s2) {
  s2.next.prev = s1.prev;
  s1.prev.next = s2.next;
  s2.next = s1.next;
  s1.next.prev = s2;
  s1.prev = s1;
  s1.next = s1;
  
}

function transfer_r(s1, s2) {
  s2.prev.next = s1.next;
  s1.next.prev = s2.prev;
  s2.prev = s1.prev;
  s1.prev.next = s2;
  s1.prev = s1;
  s1.next = s1;
  
}

function iter_l(f, seq) {
  var _curr = seq.next;
  while(true) {
    var curr = _curr;
    if (curr === seq) {
      return ;
    }
    if (curr.node_active) {
      Curry._1(f, curr.node_data);
    }
    _curr = curr.node_next;
    continue ;
  };
}

function iter_r(f, seq) {
  var _curr = seq.prev;
  while(true) {
    var curr = _curr;
    if (curr === seq) {
      return ;
    }
    if (curr.node_active) {
      Curry._1(f, curr.node_data);
    }
    _curr = curr.node_prev;
    continue ;
  };
}

function iter_node_l(f, seq) {
  var _curr = seq.next;
  while(true) {
    var curr = _curr;
    if (curr === seq) {
      return ;
    }
    if (curr.node_active) {
      Curry._1(f, curr);
    }
    _curr = curr.node_next;
    continue ;
  };
}

function iter_node_r(f, seq) {
  var _curr = seq.prev;
  while(true) {
    var curr = _curr;
    if (curr === seq) {
      return ;
    }
    if (curr.node_active) {
      Curry._1(f, curr);
    }
    _curr = curr.node_prev;
    continue ;
  };
}

function fold_l(f, seq, acc) {
  var _curr = seq.next;
  var _acc = acc;
  while(true) {
    var acc$1 = _acc;
    var curr = _curr;
    if (curr === seq) {
      return acc$1;
    }
    if (curr.node_active) {
      _acc = Curry._2(f, curr.node_data, acc$1);
      _curr = curr.node_next;
      continue ;
    }
    _curr = curr.node_next;
    continue ;
  };
}

function fold_r(f, seq, acc) {
  var _curr = seq.prev;
  var _acc = acc;
  while(true) {
    var acc$1 = _acc;
    var curr = _curr;
    if (curr === seq) {
      return acc$1;
    }
    if (curr.node_active) {
      _acc = Curry._2(f, curr.node_data, acc$1);
      _curr = curr.node_prev;
      continue ;
    }
    _curr = curr.node_prev;
    continue ;
  };
}

function find_node_l(f, seq) {
  var _curr = seq.next;
  while(true) {
    var curr = _curr;
    if (curr !== seq) {
      if (curr.node_active) {
        if (Curry._1(f, curr.node_data)) {
          return curr;
        }
        _curr = curr.node_next;
        continue ;
      }
      _curr = curr.node_next;
      continue ;
    }
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  };
}

function find_node_r(f, seq) {
  var _curr = seq.prev;
  while(true) {
    var curr = _curr;
    if (curr !== seq) {
      if (curr.node_active) {
        if (Curry._1(f, curr.node_data)) {
          return curr;
        }
        _curr = curr.node_prev;
        continue ;
      }
      _curr = curr.node_prev;
      continue ;
    }
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  };
}

function find_node_opt_l(f, seq) {
  try {
    return find_node_l(f, seq);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "Not_found") {
      return ;
    }
    throw exn;
  }
}

function find_node_opt_r(f, seq) {
  try {
    return find_node_r(f, seq);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "Not_found") {
      return ;
    }
    throw exn;
  }
}

var LwtSeq = {
  Empty: Empty,
  get: get,
  set: set,
  remove: remove,
  create: create,
  clear: clear,
  is_empty: is_empty,
  length: length,
  add_l: add_l,
  add_r: add_r,
  take_l: take_l,
  take_r: take_r,
  take_opt_l: take_opt_l,
  take_opt_r: take_opt_r,
  transfer_l: transfer_l,
  transfer_r: transfer_r,
  iter_l: iter_l,
  iter_r: iter_r,
  iter_node_l: iter_node_l,
  iter_node_r: iter_node_r,
  fold_l: fold_l,
  fold_r: fold_r,
  find_node_l: find_node_l,
  find_node_r: find_node_r,
  find_node_opt_l: find_node_opt_l,
  find_node_opt_r: find_node_opt_r
};

var compare = Caml_obj.caml_compare;

var Storage_map = $$Map.Make({
      compare: compare
    });

var Main_internal_types = {};

var Result = {};

function to_public_promise(prim) {
  return prim;
}

function to_public_resolver(prim) {
  return prim;
}

function to_internal_promise(p) {
  return p;
}

function to_internal_resolver(r) {
  return r;
}

function state_of_result(x) {
  if (x.TAG === /* Ok */0) {
    return {
            TAG: /* Fulfilled */0,
            _0: x._0
          };
  } else {
    return {
            TAG: /* Rejected */1,
            _0: x._0
          };
  }
}

var Public_types = {
  Result: Result,
  to_public_promise: to_public_promise,
  to_public_resolver: to_public_resolver,
  to_internal_promise: to_internal_promise,
  to_internal_resolver: to_internal_resolver,
  state_of_result: state_of_result
};

function identical(p1, p2) {
  return p1 === p2;
}

function underlying(p) {
  var p$prime = p.state;
  if (p$prime.TAG !== /* Proxy */3) {
    return p;
  }
  var p$prime$1 = p$prime._0;
  var p$prime$prime = underlying(p$prime$1);
  if (p$prime$prime !== p$prime$1) {
    p.state = {
      TAG: /* Proxy */3,
      _0: p$prime$prime
    };
  }
  return p$prime$prime;
}

function set_promise_state(p, state) {
  p.state = state;
  return p;
}

function may_now_be_proxy(p) {
  return p;
}

var Basic_helpers = {
  identical: identical,
  underlying: underlying,
  set_promise_state: set_promise_state,
  may_now_be_proxy: may_now_be_proxy
};

var next_key_id = {
  contents: 0
};

function new_key(param) {
  var id = next_key_id.contents;
  next_key_id.contents = id + 1 | 0;
  return {
          id: id,
          value: undefined
        };
}

var current_storage = {
  contents: Storage_map.empty
};

function get$1(key) {
  if (!Curry._2(Storage_map.mem, key.id, current_storage.contents)) {
    return ;
  }
  var refresh = Curry._2(Storage_map.find, key.id, current_storage.contents);
  Curry._1(refresh, undefined);
  var value = key.value;
  key.value = undefined;
  return value;
}

function with_value(key, value, f) {
  var new_storage;
  if (value !== undefined) {
    var refresh = function (param) {
      key.value = value;
      
    };
    new_storage = Curry._3(Storage_map.add, key.id, refresh, current_storage.contents);
  } else {
    new_storage = Curry._2(Storage_map.remove, key.id, current_storage.contents);
  }
  var saved_storage = current_storage.contents;
  current_storage.contents = new_storage;
  try {
    var result = Curry._1(f, undefined);
    current_storage.contents = saved_storage;
    return result;
  }
  catch (exn){
    current_storage.contents = saved_storage;
    throw exn;
  }
}

var Sequence_associated_storage = {
  new_key: new_key,
  get: get$1,
  with_value: with_value,
  current_storage: current_storage
};

function concat_regular_callbacks(l1, l2) {
  if (typeof l1 === "number") {
    return l2;
  } else if (typeof l2 === "number") {
    return l1;
  } else {
    return {
            TAG: /* Regular_callback_list_concat */0,
            _0: l1,
            _1: l2
          };
  }
}

function concat_cancel_callbacks(l1, l2) {
  if (typeof l1 === "number") {
    return l2;
  } else if (typeof l2 === "number") {
    return l1;
  } else {
    return {
            TAG: /* Cancel_callback_list_concat */0,
            _0: l1,
            _1: l2
          };
  }
}

function clean_up_callback_cells(callbacks) {
  if (typeof callbacks === "number") {
    return callbacks;
  }
  switch (callbacks.TAG | 0) {
    case /* Regular_callback_list_concat */0 :
        var l1 = clean_up_callback_cells(callbacks._0);
        var l2 = clean_up_callback_cells(callbacks._1);
        return concat_regular_callbacks(l1, l2);
    case /* Regular_callback_list_implicitly_removed_callback */1 :
        return callbacks;
    case /* Regular_callback_list_explicitly_removable_callback */2 :
        var match = callbacks._0.contents;
        if (match !== undefined) {
          return callbacks;
        } else {
          return /* Regular_callback_list_empty */0;
        }
    
  }
}

function clear_explicitly_removable_callback_cell(cell, ps) {
  cell.contents = undefined;
  return List.iter((function (p) {
                var callbacks = underlying(p).state;
                switch (callbacks.TAG | 0) {
                  case /* Fulfilled */0 :
                  case /* Rejected */1 :
                      return ;
                  case /* Pending */2 :
                      var callbacks$1 = callbacks._0;
                      var match = callbacks$1.regular_callbacks;
                      if (typeof match !== "number" && match.TAG === /* Regular_callback_list_explicitly_removable_callback */2) {
                        callbacks$1.regular_callbacks = /* Regular_callback_list_empty */0;
                        return ;
                      }
                      var cleanups_deferred = callbacks$1.cleanups_deferred + 1 | 0;
                      if (cleanups_deferred > 42) {
                        callbacks$1.cleanups_deferred = 0;
                        callbacks$1.regular_callbacks = clean_up_callback_cells(callbacks$1.regular_callbacks);
                      } else {
                        callbacks$1.cleanups_deferred = cleanups_deferred;
                      }
                      return ;
                  
                }
              }), ps);
}

function merge_callbacks(from, into) {
  var regular_callbacks = concat_regular_callbacks(into.regular_callbacks, from.regular_callbacks);
  var cleanups_deferred = into.cleanups_deferred + from.cleanups_deferred | 0;
  var match = cleanups_deferred > 42 ? [
      clean_up_callback_cells(regular_callbacks),
      0
    ] : [
      regular_callbacks,
      cleanups_deferred
    ];
  var cancel_callbacks = concat_cancel_callbacks(into.cancel_callbacks, from.cancel_callbacks);
  into.regular_callbacks = match[0];
  into.cancel_callbacks = cancel_callbacks;
  into.cleanups_deferred = match[1];
  
}

function add_regular_callback_list_node(callbacks, node) {
  var existing = callbacks.regular_callbacks;
  callbacks.regular_callbacks = typeof existing === "number" ? node : ({
        TAG: /* Regular_callback_list_concat */0,
        _0: node,
        _1: existing
      });
  
}

function add_implicitly_removed_callback(callbacks, f) {
  return add_regular_callback_list_node(callbacks, {
              TAG: /* Regular_callback_list_implicitly_removed_callback */1,
              _0: f
            });
}

function add_explicitly_removable_callback_and_give_cell(ps, f) {
  var cell = {};
  var self_removing_callback_wrapper = function (result) {
    clear_explicitly_removable_callback_cell(cell, ps);
    return Curry._1(f, result);
  };
  Caml_obj.update_dummy(cell, {
        contents: self_removing_callback_wrapper
      });
  var node = {
    TAG: /* Regular_callback_list_explicitly_removable_callback */2,
    _0: cell
  };
  List.iter((function (p) {
          var callbacks = underlying(p).state;
          switch (callbacks.TAG | 0) {
            case /* Fulfilled */0 :
                throw {
                      RE_EXN_ID: "Assert_failure",
                      _1: [
                        "Lwt.re",
                        727,
                        27
                      ],
                      Error: new Error()
                    };
            case /* Rejected */1 :
                throw {
                      RE_EXN_ID: "Assert_failure",
                      _1: [
                        "Lwt.re",
                        728,
                        26
                      ],
                      Error: new Error()
                    };
            case /* Pending */2 :
                return add_regular_callback_list_node(callbacks._0, node);
            
          }
        }), ps);
  return cell;
}

function add_explicitly_removable_callback_to_each_of(ps, f) {
  add_explicitly_removable_callback_and_give_cell(ps, f);
  
}

function add_explicitly_removable_callback_and_give_remove_function(ps, f) {
  var cell = add_explicitly_removable_callback_and_give_cell(ps, f);
  return function (param) {
    return clear_explicitly_removable_callback_cell(cell, ps);
  };
}

function add_cancel_callback(callbacks, f) {
  var node_0 = current_storage.contents;
  var node = {
    TAG: /* Cancel_callback_list_callback */1,
    _0: node_0,
    _1: f
  };
  var match = callbacks.cancel_callbacks;
  callbacks.cancel_callbacks = typeof match === "number" ? node : ({
        TAG: /* Cancel_callback_list_concat */0,
        _0: node,
        _1: callbacks.cancel_callbacks
      });
  
}

var Pending_callbacks = {
  add_implicitly_removed_callback: add_implicitly_removed_callback,
  add_explicitly_removable_callback_to_each_of: add_explicitly_removable_callback_to_each_of,
  add_explicitly_removable_callback_and_give_remove_function: add_explicitly_removable_callback_and_give_remove_function,
  add_cancel_callback: add_cancel_callback,
  merge_callbacks: merge_callbacks
};

var async_exception_hook = {
  contents: (function (exn) {
      Pervasives.prerr_string("Fatal error: exception ");
      Pervasives.prerr_string(Printexc.to_string(exn));
      Pervasives.prerr_char(/* '\n' */10);
      Printexc.print_backtrace(Pervasives.stderr);
      Pervasives.flush(Pervasives.stderr);
      return Pervasives.exit(2);
    })
};

function handle_with_async_exception_hook(f, v) {
  try {
    return Curry._1(f, v);
  }
  catch (raw_exn){
    return Curry._1(async_exception_hook.contents, Caml_js_exceptions.internalToOCamlException(raw_exn));
  }
}

var Canceled = /* @__PURE__ */Caml_exceptions.create("Lwt-Repacked.Resolution_loop.Canceled");

function run_callbacks(callbacks, result) {
  var run_cancel_callbacks = function (fs) {
    var iter_callback_list = function (_fs, _rest) {
      while(true) {
        var rest = _rest;
        var fs = _fs;
        if (typeof fs === "number") {
          return iter_list(rest);
        }
        switch (fs.TAG | 0) {
          case /* Cancel_callback_list_concat */0 :
              _rest = {
                hd: fs._1,
                tl: rest
              };
              _fs = fs._0;
              continue ;
          case /* Cancel_callback_list_callback */1 :
              current_storage.contents = fs._0;
              handle_with_async_exception_hook(fs._1, undefined);
              return iter_list(rest);
          case /* Cancel_callback_list_remove_sequence_node */2 :
              LwtDllist$Repacked.remove(fs._0);
              return iter_list(rest);
          
        }
      };
    };
    var iter_list = function (rest) {
      if (rest) {
        return iter_callback_list(rest.hd, rest.tl);
      }
      
    };
    return iter_callback_list(fs, /* [] */0);
  };
  var is_canceled;
  is_canceled = result.TAG === /* Fulfilled */0 ? false : result._0.RE_EXN_ID === Canceled;
  if (is_canceled) {
    run_cancel_callbacks(callbacks.cancel_callbacks);
  }
  var fs = callbacks.regular_callbacks;
  var iter_callback_list = function (_fs, _rest) {
    while(true) {
      var rest = _rest;
      var fs = _fs;
      if (typeof fs === "number") {
        return iter_list(rest);
      }
      switch (fs.TAG | 0) {
        case /* Regular_callback_list_concat */0 :
            _rest = {
              hd: fs._1,
              tl: rest
            };
            _fs = fs._0;
            continue ;
        case /* Regular_callback_list_implicitly_removed_callback */1 :
            Curry._1(fs._0, result);
            return iter_list(rest);
        case /* Regular_callback_list_explicitly_removable_callback */2 :
            var f = fs._0.contents;
            if (f !== undefined) {
              Curry._1(f, result);
              return iter_list(rest);
            } else {
              return iter_list(rest);
            }
        
      }
    };
  };
  var iter_list = function (rest) {
    if (rest) {
      return iter_callback_list(rest.hd, rest.tl);
    }
    
  };
  return iter_callback_list(fs, /* [] */0);
}

var current_callback_nesting_depth = {
  contents: 0
};

var deferred_callbacks = Queue.create(undefined);

function enter_resolution_loop(param) {
  current_callback_nesting_depth.contents = current_callback_nesting_depth.contents + 1 | 0;
  return current_storage.contents;
}

function leave_resolution_loop(storage_snapshot) {
  if (current_callback_nesting_depth.contents === 1) {
    while(!Queue.is_empty(deferred_callbacks)) {
      var match = Queue.pop(deferred_callbacks);
      run_callbacks(match[0], match[1]);
    };
  }
  current_callback_nesting_depth.contents = current_callback_nesting_depth.contents - 1 | 0;
  current_storage.contents = storage_snapshot;
  
}

function run_in_resolution_loop(f) {
  var storage_snapshot = enter_resolution_loop(undefined);
  var result = Curry._1(f, undefined);
  leave_resolution_loop(storage_snapshot);
  return result;
}

function abandon_wakeups(param) {
  if (current_callback_nesting_depth.contents !== 0) {
    return leave_resolution_loop(Storage_map.empty);
  }
  
}

function run_callbacks_or_defer_them(allow_deferringOpt, maximum_callback_nesting_depthOpt, callbacks, result) {
  var allow_deferring = allow_deferringOpt !== undefined ? allow_deferringOpt : true;
  var maximum_callback_nesting_depth = maximum_callback_nesting_depthOpt !== undefined ? maximum_callback_nesting_depthOpt : 42;
  var should_defer = allow_deferring && current_callback_nesting_depth.contents >= maximum_callback_nesting_depth;
  if (should_defer) {
    return Queue.push([
                callbacks,
                result
              ], deferred_callbacks);
  } else {
    return run_in_resolution_loop(function (param) {
                return run_callbacks(callbacks, result);
              });
  }
}

function resolve(allow_deferring, maximum_callback_nesting_depth, p, result) {
  var callbacks = p.state;
  var p$1 = set_promise_state(p, result);
  run_callbacks_or_defer_them(allow_deferring, maximum_callback_nesting_depth, callbacks._0, result);
  return p$1;
}

function run_callback_or_defer_it(run_immediately_and_ensure_tail_callOpt, f, if_deferred) {
  var run_immediately_and_ensure_tail_call = run_immediately_and_ensure_tail_callOpt !== undefined ? run_immediately_and_ensure_tail_callOpt : false;
  if (run_immediately_and_ensure_tail_call) {
    return Curry._1(f, undefined);
  }
  var should_defer = current_callback_nesting_depth.contents >= 42;
  if (!should_defer) {
    return run_in_resolution_loop(function (param) {
                return Curry._1(f, undefined);
              });
  }
  var match = Curry._1(if_deferred, undefined);
  var deferred_record = {
    regular_callbacks: {
      TAG: /* Regular_callback_list_implicitly_removed_callback */1,
      _0: match[1]
    },
    cancel_callbacks: /* Cancel_callback_list_empty */0,
    how_to_cancel: /* Not_cancelable */0,
    cleanups_deferred: 0
  };
  Queue.push([
        deferred_record,
        match[2]
      ], deferred_callbacks);
  return match[0];
}

var Resolution_loop = {
  resolve: resolve,
  run_callbacks_or_defer_them: run_callbacks_or_defer_them,
  run_callback_or_defer_it: run_callback_or_defer_it,
  handle_with_async_exception_hook: handle_with_async_exception_hook,
  abandon_wakeups: abandon_wakeups,
  Canceled: Canceled,
  async_exception_hook: async_exception_hook
};

function wakeup_general(api_function_name, r, result) {
  var p = underlying(r);
  var match = p.state;
  switch (match.TAG | 0) {
    case /* Fulfilled */0 :
        return Curry._1(Printf.ksprintf(Pervasives.invalid_arg, /* Format */{
                        _0: {
                          TAG: /* String_literal */11,
                          _0: "Lwt.",
                          _1: {
                            TAG: /* String */2,
                            _0: /* No_padding */0,
                            _1: /* End_of_format */0
                          }
                        },
                        _1: "Lwt.%s"
                      }), api_function_name);
    case /* Rejected */1 :
        if (match._0.RE_EXN_ID === Canceled) {
          return ;
        } else {
          return Curry._1(Printf.ksprintf(Pervasives.invalid_arg, /* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "Lwt.",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: /* End_of_format */0
                            }
                          },
                          _1: "Lwt.%s"
                        }), api_function_name);
        }
    case /* Pending */2 :
        var result$1 = state_of_result(result);
        resolve(false, undefined, p, result$1);
        return ;
    
  }
}

function wakeup_result(r, result) {
  return wakeup_general("wakeup_result", r, result);
}

function wakeup(r, v) {
  return wakeup_general("wakeup", r, {
              TAG: /* Ok */0,
              _0: v
            });
}

function wakeup_exn(r, exn) {
  return wakeup_general("wakeup_exn", r, {
              TAG: /* Error */1,
              _0: exn
            });
}

function wakeup_later_general(api_function_name, r, result) {
  var p = underlying(r);
  var match = p.state;
  switch (match.TAG | 0) {
    case /* Fulfilled */0 :
        return Curry._1(Printf.ksprintf(Pervasives.invalid_arg, /* Format */{
                        _0: {
                          TAG: /* String_literal */11,
                          _0: "Lwt.",
                          _1: {
                            TAG: /* String */2,
                            _0: /* No_padding */0,
                            _1: /* End_of_format */0
                          }
                        },
                        _1: "Lwt.%s"
                      }), api_function_name);
    case /* Rejected */1 :
        if (match._0.RE_EXN_ID === Canceled) {
          return ;
        } else {
          return Curry._1(Printf.ksprintf(Pervasives.invalid_arg, /* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "Lwt.",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: /* End_of_format */0
                            }
                          },
                          _1: "Lwt.%s"
                        }), api_function_name);
        }
    case /* Pending */2 :
        var result$1 = state_of_result(result);
        resolve(undefined, 1, p, result$1);
        return ;
    
  }
}

function wakeup_later_result(r, result) {
  return wakeup_later_general("wakeup_later_result", r, result);
}

function wakeup_later(r, v) {
  return wakeup_later_general("wakeup_later", r, {
              TAG: /* Ok */0,
              _0: v
            });
}

function wakeup_later_exn(r, exn) {
  return wakeup_later_general("wakeup_later_exn", r, {
              TAG: /* Error */1,
              _0: exn
            });
}

function cancel(p) {
  var canceled_result = {
    TAG: /* Rejected */1,
    _0: {
      RE_EXN_ID: Canceled
    }
  };
  var propagate_cancel = function (p) {
    var cancel_and_collect_callbacks = function (callbacks_accumulator, _p) {
      while(true) {
        var p = _p;
        var p$1 = underlying(p);
        var callbacks = p$1.state;
        switch (callbacks.TAG | 0) {
          case /* Fulfilled */0 :
          case /* Rejected */1 :
              return callbacks_accumulator;
          case /* Pending */2 :
              var callbacks$1 = callbacks._0;
              var p$prime = callbacks$1.how_to_cancel;
              if (typeof p$prime === "number") {
                if (p$prime === /* Not_cancelable */0) {
                  return callbacks_accumulator;
                }
                set_promise_state(p$1, canceled_result);
                return {
                        hd: callbacks$1,
                        tl: callbacks_accumulator
                      };
              } else {
                if (p$prime.TAG !== /* Propagate_cancel_to_one */0) {
                  return List.fold_left(cancel_and_collect_callbacks, callbacks_accumulator, p$prime._0);
                }
                _p = p$prime._0;
                continue ;
              }
          
        }
      };
    };
    return cancel_and_collect_callbacks(/* [] */0, p);
  };
  var callbacks = propagate_cancel(p);
  return List.iter((function (callbacks) {
                return run_callbacks_or_defer_them(false, undefined, callbacks, canceled_result);
              }), callbacks);
}

var Resolving = {
  wakeup_later_result: wakeup_later_result,
  wakeup_later: wakeup_later,
  wakeup_later_exn: wakeup_later_exn,
  wakeup_result: wakeup_result,
  wakeup: wakeup,
  wakeup_exn: wakeup_exn,
  cancel: cancel
};

function $$return(v) {
  return {
          state: {
            TAG: /* Fulfilled */0,
            _0: v
          }
        };
}

function of_result(result) {
  return {
          state: state_of_result(result)
        };
}

function fail(exn) {
  return {
          state: {
            TAG: /* Rejected */1,
            _0: exn
          }
        };
}

var return_unit = {
  state: {
    TAG: /* Fulfilled */0,
    _0: undefined
  }
};

var return_none = {
  state: {
    TAG: /* Fulfilled */0,
    _0: undefined
  }
};

function return_some(x) {
  return {
          state: {
            TAG: /* Fulfilled */0,
            _0: Caml_option.some(x)
          }
        };
}

var return_nil = {
  state: {
    TAG: /* Fulfilled */0,
    _0: /* [] */0
  }
};

var return_true = {
  state: {
    TAG: /* Fulfilled */0,
    _0: true
  }
};

var return_false = {
  state: {
    TAG: /* Fulfilled */0,
    _0: false
  }
};

function return_ok(x) {
  return {
          state: {
            TAG: /* Fulfilled */0,
            _0: {
              TAG: /* Ok */0,
              _0: x
            }
          }
        };
}

function return_error(x) {
  return {
          state: {
            TAG: /* Fulfilled */0,
            _0: {
              TAG: /* Error */1,
              _0: x
            }
          }
        };
}

function fail_with(msg) {
  return {
          state: {
            TAG: /* Rejected */1,
            _0: {
              RE_EXN_ID: "Failure",
              _1: msg
            }
          }
        };
}

function fail_invalid_arg(msg) {
  return {
          state: {
            TAG: /* Rejected */1,
            _0: {
              RE_EXN_ID: "Invalid_argument",
              _1: msg
            }
          }
        };
}

var Trivial_promises = {
  $$return: $$return,
  fail: fail,
  of_result: of_result,
  return_unit: return_unit,
  return_true: return_true,
  return_false: return_false,
  return_none: return_none,
  return_some: return_some,
  return_ok: return_ok,
  return_error: return_error,
  return_nil: return_nil,
  fail_with: fail_with,
  fail_invalid_arg: fail_invalid_arg
};

function new_pending(how_to_cancel) {
  var state = {
    TAG: /* Pending */2,
    _0: {
      regular_callbacks: /* Regular_callback_list_empty */0,
      cancel_callbacks: /* Cancel_callback_list_empty */0,
      how_to_cancel: how_to_cancel,
      cleanups_deferred: 0
    }
  };
  return {
          state: state
        };
}

function propagate_cancel_to_several(ps) {
  return {
          TAG: /* Propagate_cancel_to_several */1,
          _0: ps
        };
}

function wait(param) {
  var state = {
    TAG: /* Pending */2,
    _0: {
      regular_callbacks: /* Regular_callback_list_empty */0,
      cancel_callbacks: /* Cancel_callback_list_empty */0,
      how_to_cancel: /* Not_cancelable */0,
      cleanups_deferred: 0
    }
  };
  var p = {
    state: state
  };
  return [
          p,
          p
        ];
}

function task(param) {
  var state = {
    TAG: /* Pending */2,
    _0: {
      regular_callbacks: /* Regular_callback_list_empty */0,
      cancel_callbacks: /* Cancel_callback_list_empty */0,
      how_to_cancel: /* Cancel_this_promise */1,
      cleanups_deferred: 0
    }
  };
  var p = {
    state: state
  };
  return [
          p,
          p
        ];
}

function waiter_of_wakener(r) {
  return r;
}

function add_task_r(sequence) {
  var state = {
    TAG: /* Pending */2,
    _0: {
      regular_callbacks: /* Regular_callback_list_empty */0,
      cancel_callbacks: /* Cancel_callback_list_empty */0,
      how_to_cancel: /* Cancel_this_promise */1,
      cleanups_deferred: 0
    }
  };
  var p = {
    state: state
  };
  var node = LwtDllist$Repacked.add_r(p, sequence);
  var callbacks = p.state;
  callbacks._0.cancel_callbacks = {
    TAG: /* Cancel_callback_list_remove_sequence_node */2,
    _0: node
  };
  return p;
}

function add_task_l(sequence) {
  var state = {
    TAG: /* Pending */2,
    _0: {
      regular_callbacks: /* Regular_callback_list_empty */0,
      cancel_callbacks: /* Cancel_callback_list_empty */0,
      how_to_cancel: /* Cancel_this_promise */1,
      cleanups_deferred: 0
    }
  };
  var p = {
    state: state
  };
  var node = LwtDllist$Repacked.add_l(p, sequence);
  var callbacks = p.state;
  callbacks._0.cancel_callbacks = {
    TAG: /* Cancel_callback_list_remove_sequence_node */2,
    _0: node
  };
  return p;
}

function $$protected(p) {
  var match = underlying(p).state;
  switch (match.TAG | 0) {
    case /* Fulfilled */0 :
    case /* Rejected */1 :
        return p;
    case /* Pending */2 :
        var state = {
          TAG: /* Pending */2,
          _0: {
            regular_callbacks: /* Regular_callback_list_empty */0,
            cancel_callbacks: /* Cancel_callback_list_empty */0,
            how_to_cancel: /* Cancel_this_promise */1,
            cleanups_deferred: 0
          }
        };
        var p$prime = {
          state: state
        };
        var callback = function (p_result) {
          var p$prime$1 = underlying(p$prime);
          resolve(false, undefined, p$prime$1, p_result);
          
        };
        var remove_the_callback = add_explicitly_removable_callback_and_give_remove_function({
              hd: p,
              tl: /* [] */0
            }, callback);
        var p$prime_callbacks = p$prime.state;
        add_cancel_callback(p$prime_callbacks._0, remove_the_callback);
        return p$prime;
    
  }
}

function no_cancel(p) {
  var p_callbacks = underlying(p).state;
  switch (p_callbacks.TAG | 0) {
    case /* Fulfilled */0 :
    case /* Rejected */1 :
        return p;
    case /* Pending */2 :
        var state = {
          TAG: /* Pending */2,
          _0: {
            regular_callbacks: /* Regular_callback_list_empty */0,
            cancel_callbacks: /* Cancel_callback_list_empty */0,
            how_to_cancel: /* Not_cancelable */0,
            cleanups_deferred: 0
          }
        };
        var p$prime = {
          state: state
        };
        var callback = function (p_result) {
          var p$prime$1 = underlying(p$prime);
          resolve(false, undefined, p$prime$1, p_result);
          
        };
        add_regular_callback_list_node(p_callbacks._0, {
              TAG: /* Regular_callback_list_implicitly_removed_callback */1,
              _0: callback
            });
        return p$prime;
    
  }
}

var Pending_promises = {
  new_pending: new_pending,
  propagate_cancel_to_several: propagate_cancel_to_several,
  wait: wait,
  task: task,
  waiter_of_wakener: waiter_of_wakener,
  add_task_r: add_task_r,
  add_task_l: add_task_l,
  $$protected: $$protected,
  no_cancel: no_cancel
};

function make_into_proxy(outer_promise, user_provided_promise) {
  var p$prime = underlying(user_provided_promise);
  if (p$prime === outer_promise) {
    return p$prime;
  }
  var p$prime_callbacks = p$prime.state;
  switch (p$prime_callbacks.TAG | 0) {
    case /* Fulfilled */0 :
    case /* Rejected */1 :
        return resolve(false, undefined, outer_promise, p$prime.state);
    case /* Pending */2 :
        var p$prime_callbacks$1 = p$prime_callbacks._0;
        var outer_callbacks = outer_promise.state;
        var outer_callbacks$1 = outer_callbacks._0;
        merge_callbacks(p$prime_callbacks$1, outer_callbacks$1);
        outer_callbacks$1.how_to_cancel = p$prime_callbacks$1.how_to_cancel;
        set_promise_state(p$prime, {
              TAG: /* Proxy */3,
              _0: outer_promise
            });
        return outer_promise;
    
  }
}

function bind(p, f) {
  var p$1 = underlying(p);
  var create_result_promise_and_callback_if_deferred = function (param) {
    var p$prime$prime = new_pending({
          TAG: /* Propagate_cancel_to_one */0,
          _0: p$1
        });
    var saved_storage = current_storage.contents;
    var callback = function (p_result) {
      if (p_result.TAG === /* Fulfilled */0) {
        current_storage.contents = saved_storage;
        var p$prime;
        try {
          p$prime = Curry._1(f, p_result._0);
        }
        catch (raw_exn){
          p$prime = {
            state: {
              TAG: /* Rejected */1,
              _0: Caml_js_exceptions.internalToOCamlException(raw_exn)
            }
          };
        }
        var p$prime$prime$1 = underlying(p$prime$prime);
        make_into_proxy(p$prime$prime$1, p$prime);
        return ;
      }
      var p$prime$prime$2 = underlying(p$prime$prime);
      resolve(false, undefined, p$prime$prime$2, p_result);
      
    };
    return [
            p$prime$prime,
            callback
          ];
  };
  var v = p$1.state;
  switch (v.TAG | 0) {
    case /* Fulfilled */0 :
        var v$1 = v._0;
        return run_callback_or_defer_it(true, (function (param) {
                      return Curry._1(f, v$1);
                    }), (function (param) {
                      var match = create_result_promise_and_callback_if_deferred(undefined);
                      return [
                              match[0],
                              match[1],
                              p$1.state
                            ];
                    }));
    case /* Rejected */1 :
        return {
                state: v
              };
    case /* Pending */2 :
        var match = create_result_promise_and_callback_if_deferred(undefined);
        add_regular_callback_list_node(v._0, {
              TAG: /* Regular_callback_list_implicitly_removed_callback */1,
              _0: match[1]
            });
        return match[0];
    
  }
}

function backtrace_bind(add_loc, p, f) {
  var p$1 = underlying(p);
  var create_result_promise_and_callback_if_deferred = function (param) {
    var p$prime$prime = new_pending({
          TAG: /* Propagate_cancel_to_one */0,
          _0: p$1
        });
    var saved_storage = current_storage.contents;
    var callback = function (p_result) {
      if (p_result.TAG === /* Fulfilled */0) {
        current_storage.contents = saved_storage;
        var p$prime;
        try {
          p$prime = Curry._1(f, p_result._0);
        }
        catch (raw_exn){
          var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          var exn$1 = Curry._1(add_loc, exn);
          p$prime = {
            state: {
              TAG: /* Rejected */1,
              _0: exn$1
            }
          };
        }
        var p$prime$prime$1 = underlying(p$prime$prime);
        make_into_proxy(p$prime$prime$1, p$prime);
        return ;
      }
      var p$prime$prime$2 = underlying(p$prime$prime);
      resolve(false, undefined, p$prime$prime$2, {
            TAG: /* Rejected */1,
            _0: Curry._1(add_loc, p_result._0)
          });
      
    };
    return [
            p$prime$prime,
            callback
          ];
  };
  var v = p$1.state;
  switch (v.TAG | 0) {
    case /* Fulfilled */0 :
        var v$1 = v._0;
        return run_callback_or_defer_it(true, (function (param) {
                      return Curry._1(f, v$1);
                    }), (function (param) {
                      var match = create_result_promise_and_callback_if_deferred(undefined);
                      return [
                              match[0],
                              match[1],
                              p$1.state
                            ];
                    }));
    case /* Rejected */1 :
        return {
                state: {
                  TAG: /* Rejected */1,
                  _0: Curry._1(add_loc, v._0)
                }
              };
    case /* Pending */2 :
        var match = create_result_promise_and_callback_if_deferred(undefined);
        add_regular_callback_list_node(v._0, {
              TAG: /* Regular_callback_list_implicitly_removed_callback */1,
              _0: match[1]
            });
        return match[0];
    
  }
}

function map(f, p) {
  var p$1 = underlying(p);
  var create_result_promise_and_callback_if_deferred = function (param) {
    var p$prime$prime = new_pending({
          TAG: /* Propagate_cancel_to_one */0,
          _0: p$1
        });
    var saved_storage = current_storage.contents;
    var callback = function (p_result) {
      if (p_result.TAG === /* Fulfilled */0) {
        current_storage.contents = saved_storage;
        var p$prime$prime_result;
        try {
          p$prime$prime_result = {
            TAG: /* Fulfilled */0,
            _0: Curry._1(f, p_result._0)
          };
        }
        catch (raw_exn){
          var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          p$prime$prime_result = {
            TAG: /* Rejected */1,
            _0: exn
          };
        }
        var p$prime$prime$1 = underlying(p$prime$prime);
        resolve(false, undefined, p$prime$prime$1, p$prime$prime_result);
        return ;
      }
      var p$prime$prime$2 = underlying(p$prime$prime);
      resolve(false, undefined, p$prime$prime$2, p_result);
      
    };
    return [
            p$prime$prime,
            callback
          ];
  };
  var v = p$1.state;
  switch (v.TAG | 0) {
    case /* Fulfilled */0 :
        var v$1 = v._0;
        return run_callback_or_defer_it(true, (function (param) {
                      var tmp;
                      try {
                        tmp = {
                          TAG: /* Fulfilled */0,
                          _0: Curry._1(f, v$1)
                        };
                      }
                      catch (raw_exn){
                        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                        tmp = {
                          TAG: /* Rejected */1,
                          _0: exn
                        };
                      }
                      return {
                              state: tmp
                            };
                    }), (function (param) {
                      var match = create_result_promise_and_callback_if_deferred(undefined);
                      return [
                              match[0],
                              match[1],
                              p$1.state
                            ];
                    }));
    case /* Rejected */1 :
        return {
                state: v
              };
    case /* Pending */2 :
        var match = create_result_promise_and_callback_if_deferred(undefined);
        add_regular_callback_list_node(v._0, {
              TAG: /* Regular_callback_list_implicitly_removed_callback */1,
              _0: match[1]
            });
        return match[0];
    
  }
}

function $$catch(f, h) {
  var p;
  try {
    p = Curry._1(f, undefined);
  }
  catch (raw_exn){
    p = {
      state: {
        TAG: /* Rejected */1,
        _0: Caml_js_exceptions.internalToOCamlException(raw_exn)
      }
    };
  }
  var p$1 = underlying(p);
  var create_result_promise_and_callback_if_deferred = function (param) {
    var p$prime$prime = new_pending({
          TAG: /* Propagate_cancel_to_one */0,
          _0: p$1
        });
    var saved_storage = current_storage.contents;
    var callback = function (p_result) {
      if (p_result.TAG === /* Fulfilled */0) {
        var p$prime$prime$1 = underlying(p$prime$prime);
        resolve(false, undefined, p$prime$prime$1, p_result);
        return ;
      }
      current_storage.contents = saved_storage;
      var p$prime;
      try {
        p$prime = Curry._1(h, p_result._0);
      }
      catch (raw_exn){
        p$prime = {
          state: {
            TAG: /* Rejected */1,
            _0: Caml_js_exceptions.internalToOCamlException(raw_exn)
          }
        };
      }
      var p$prime$prime$2 = underlying(p$prime$prime);
      make_into_proxy(p$prime$prime$2, p$prime);
      
    };
    return [
            p$prime$prime,
            callback
          ];
  };
  var exn = p$1.state;
  switch (exn.TAG | 0) {
    case /* Fulfilled */0 :
        return p$1;
    case /* Rejected */1 :
        var exn$1 = exn._0;
        return run_callback_or_defer_it(true, (function (param) {
                      return Curry._1(h, exn$1);
                    }), (function (param) {
                      var match = create_result_promise_and_callback_if_deferred(undefined);
                      return [
                              match[0],
                              match[1],
                              p$1.state
                            ];
                    }));
    case /* Pending */2 :
        var match = create_result_promise_and_callback_if_deferred(undefined);
        add_regular_callback_list_node(exn._0, {
              TAG: /* Regular_callback_list_implicitly_removed_callback */1,
              _0: match[1]
            });
        return match[0];
    
  }
}

function backtrace_catch(add_loc, f, h) {
  var p;
  try {
    p = Curry._1(f, undefined);
  }
  catch (raw_exn){
    p = {
      state: {
        TAG: /* Rejected */1,
        _0: Caml_js_exceptions.internalToOCamlException(raw_exn)
      }
    };
  }
  var p$1 = underlying(p);
  var create_result_promise_and_callback_if_deferred = function (param) {
    var p$prime$prime = new_pending({
          TAG: /* Propagate_cancel_to_one */0,
          _0: p$1
        });
    var saved_storage = current_storage.contents;
    var callback = function (p_result) {
      if (p_result.TAG === /* Fulfilled */0) {
        var p$prime$prime$1 = underlying(p$prime$prime);
        resolve(false, undefined, p$prime$prime$1, p_result);
        return ;
      }
      current_storage.contents = saved_storage;
      var p$prime;
      try {
        p$prime = Curry._1(h, p_result._0);
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        var exn$1 = Curry._1(add_loc, exn);
        p$prime = {
          state: {
            TAG: /* Rejected */1,
            _0: exn$1
          }
        };
      }
      var p$prime$prime$2 = underlying(p$prime$prime);
      make_into_proxy(p$prime$prime$2, p$prime);
      
    };
    return [
            p$prime$prime,
            callback
          ];
  };
  var exn = p$1.state;
  switch (exn.TAG | 0) {
    case /* Fulfilled */0 :
        return p$1;
    case /* Rejected */1 :
        var exn$1 = exn._0;
        return run_callback_or_defer_it(true, (function (param) {
                      return Curry._1(h, Curry._1(add_loc, exn$1));
                    }), (function (param) {
                      var match = create_result_promise_and_callback_if_deferred(undefined);
                      return [
                              match[0],
                              match[1],
                              p$1.state
                            ];
                    }));
    case /* Pending */2 :
        var match = create_result_promise_and_callback_if_deferred(undefined);
        add_regular_callback_list_node(exn._0, {
              TAG: /* Regular_callback_list_implicitly_removed_callback */1,
              _0: match[1]
            });
        return match[0];
    
  }
}

function try_bind(f, f$prime, h) {
  var p;
  try {
    p = Curry._1(f, undefined);
  }
  catch (raw_exn){
    p = {
      state: {
        TAG: /* Rejected */1,
        _0: Caml_js_exceptions.internalToOCamlException(raw_exn)
      }
    };
  }
  var p$1 = underlying(p);
  var create_result_promise_and_callback_if_deferred = function (param) {
    var p$prime$prime = new_pending({
          TAG: /* Propagate_cancel_to_one */0,
          _0: p$1
        });
    var saved_storage = current_storage.contents;
    var callback = function (p_result) {
      if (p_result.TAG === /* Fulfilled */0) {
        current_storage.contents = saved_storage;
        var p$prime;
        try {
          p$prime = Curry._1(f$prime, p_result._0);
        }
        catch (raw_exn){
          p$prime = {
            state: {
              TAG: /* Rejected */1,
              _0: Caml_js_exceptions.internalToOCamlException(raw_exn)
            }
          };
        }
        var p$prime$prime$1 = underlying(p$prime$prime);
        make_into_proxy(p$prime$prime$1, p$prime);
        return ;
      }
      current_storage.contents = saved_storage;
      var p$prime$1;
      try {
        p$prime$1 = Curry._1(h, p_result._0);
      }
      catch (raw_exn$1){
        p$prime$1 = {
          state: {
            TAG: /* Rejected */1,
            _0: Caml_js_exceptions.internalToOCamlException(raw_exn$1)
          }
        };
      }
      var p$prime$prime$2 = underlying(p$prime$prime);
      make_into_proxy(p$prime$prime$2, p$prime$1);
      
    };
    return [
            p$prime$prime,
            callback
          ];
  };
  var v = p$1.state;
  switch (v.TAG | 0) {
    case /* Fulfilled */0 :
        var v$1 = v._0;
        return run_callback_or_defer_it(true, (function (param) {
                      return Curry._1(f$prime, v$1);
                    }), (function (param) {
                      var match = create_result_promise_and_callback_if_deferred(undefined);
                      return [
                              match[0],
                              match[1],
                              p$1.state
                            ];
                    }));
    case /* Rejected */1 :
        var exn = v._0;
        return run_callback_or_defer_it(true, (function (param) {
                      return Curry._1(h, exn);
                    }), (function (param) {
                      var match = create_result_promise_and_callback_if_deferred(undefined);
                      return [
                              match[0],
                              match[1],
                              p$1.state
                            ];
                    }));
    case /* Pending */2 :
        var match = create_result_promise_and_callback_if_deferred(undefined);
        add_regular_callback_list_node(v._0, {
              TAG: /* Regular_callback_list_implicitly_removed_callback */1,
              _0: match[1]
            });
        return match[0];
    
  }
}

function backtrace_try_bind(add_loc, f, f$prime, h) {
  var p;
  try {
    p = Curry._1(f, undefined);
  }
  catch (raw_exn){
    p = {
      state: {
        TAG: /* Rejected */1,
        _0: Caml_js_exceptions.internalToOCamlException(raw_exn)
      }
    };
  }
  var p$1 = underlying(p);
  var create_result_promise_and_callback_if_deferred = function (param) {
    var p$prime$prime = new_pending({
          TAG: /* Propagate_cancel_to_one */0,
          _0: p$1
        });
    var saved_storage = current_storage.contents;
    var callback = function (p_result) {
      if (p_result.TAG === /* Fulfilled */0) {
        current_storage.contents = saved_storage;
        var p$prime;
        try {
          p$prime = Curry._1(f$prime, p_result._0);
        }
        catch (raw_exn){
          var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          var exn$1 = Curry._1(add_loc, exn);
          p$prime = {
            state: {
              TAG: /* Rejected */1,
              _0: exn$1
            }
          };
        }
        var p$prime$prime$1 = underlying(p$prime$prime);
        make_into_proxy(p$prime$prime$1, p$prime);
        return ;
      }
      current_storage.contents = saved_storage;
      var p$prime$1;
      try {
        p$prime$1 = Curry._1(h, p_result._0);
      }
      catch (raw_exn$1){
        var exn$2 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
        var exn$3 = Curry._1(add_loc, exn$2);
        p$prime$1 = {
          state: {
            TAG: /* Rejected */1,
            _0: exn$3
          }
        };
      }
      var p$prime$prime$2 = underlying(p$prime$prime);
      make_into_proxy(p$prime$prime$2, p$prime$1);
      
    };
    return [
            p$prime$prime,
            callback
          ];
  };
  var v = p$1.state;
  switch (v.TAG | 0) {
    case /* Fulfilled */0 :
        var v$1 = v._0;
        return run_callback_or_defer_it(true, (function (param) {
                      return Curry._1(f$prime, v$1);
                    }), (function (param) {
                      var match = create_result_promise_and_callback_if_deferred(undefined);
                      return [
                              match[0],
                              match[1],
                              p$1.state
                            ];
                    }));
    case /* Rejected */1 :
        var exn = v._0;
        return run_callback_or_defer_it(true, (function (param) {
                      return Curry._1(h, Curry._1(add_loc, exn));
                    }), (function (param) {
                      var match = create_result_promise_and_callback_if_deferred(undefined);
                      return [
                              match[0],
                              match[1],
                              p$1.state
                            ];
                    }));
    case /* Pending */2 :
        var match = create_result_promise_and_callback_if_deferred(undefined);
        add_regular_callback_list_node(v._0, {
              TAG: /* Regular_callback_list_implicitly_removed_callback */1,
              _0: match[1]
            });
        return match[0];
    
  }
}

function finalize(f, f$prime) {
  return try_bind(f, (function (x) {
                return bind(Curry._1(f$prime, undefined), (function (param) {
                              return {
                                      state: {
                                        TAG: /* Fulfilled */0,
                                        _0: x
                                      }
                                    };
                            }));
              }), (function (e) {
                return bind(Curry._1(f$prime, undefined), (function (param) {
                              return {
                                      state: {
                                        TAG: /* Rejected */1,
                                        _0: e
                                      }
                                    };
                            }));
              }));
}

function backtrace_finalize(add_loc, f, f$prime) {
  return backtrace_try_bind(add_loc, f, (function (x) {
                return bind(Curry._1(f$prime, undefined), (function (param) {
                              return {
                                      state: {
                                        TAG: /* Fulfilled */0,
                                        _0: x
                                      }
                                    };
                            }));
              }), (function (e) {
                return bind(Curry._1(f$prime, undefined), (function (param) {
                              var exn = Curry._1(add_loc, e);
                              return {
                                      state: {
                                        TAG: /* Rejected */1,
                                        _0: exn
                                      }
                                    };
                            }));
              }));
}

function on_cancel(p, f) {
  var p$1 = underlying(p);
  var callbacks = p$1.state;
  switch (callbacks.TAG | 0) {
    case /* Fulfilled */0 :
        return ;
    case /* Rejected */1 :
        if (callbacks._0.RE_EXN_ID === Canceled) {
          return run_callback_or_defer_it(true, (function (param) {
                        return handle_with_async_exception_hook(f, undefined);
                      }), (function (param) {
                        return [
                                undefined,
                                (function (param) {
                                    return handle_with_async_exception_hook(f, undefined);
                                  }),
                                {
                                  TAG: /* Fulfilled */0,
                                  _0: undefined
                                }
                              ];
                      }));
        } else {
          return ;
        }
    case /* Pending */2 :
        return add_cancel_callback(callbacks._0, f);
    
  }
}

function on_success(p, f) {
  var p$1 = underlying(p);
  var callback_if_deferred = function (param) {
    var saved_storage = current_storage.contents;
    return function (result) {
      if (result.TAG !== /* Fulfilled */0) {
        return ;
      }
      current_storage.contents = saved_storage;
      return handle_with_async_exception_hook(f, result._0);
    };
  };
  var v = p$1.state;
  switch (v.TAG | 0) {
    case /* Fulfilled */0 :
        var v$1 = v._0;
        return run_callback_or_defer_it(true, (function (param) {
                      return handle_with_async_exception_hook(f, v$1);
                    }), (function (param) {
                      var callback = callback_if_deferred(undefined);
                      return [
                              undefined,
                              callback,
                              p$1.state
                            ];
                    }));
    case /* Rejected */1 :
        return ;
    case /* Pending */2 :
        var callback = callback_if_deferred(undefined);
        return add_regular_callback_list_node(v._0, {
                    TAG: /* Regular_callback_list_implicitly_removed_callback */1,
                    _0: callback
                  });
    
  }
}

function on_failure(p, f) {
  var p$1 = underlying(p);
  var callback_if_deferred = function (param) {
    var saved_storage = current_storage.contents;
    return function (result) {
      if (result.TAG === /* Fulfilled */0) {
        return ;
      }
      current_storage.contents = saved_storage;
      return handle_with_async_exception_hook(f, result._0);
    };
  };
  var exn = p$1.state;
  switch (exn.TAG | 0) {
    case /* Fulfilled */0 :
        return ;
    case /* Rejected */1 :
        var exn$1 = exn._0;
        return run_callback_or_defer_it(true, (function (param) {
                      return handle_with_async_exception_hook(f, exn$1);
                    }), (function (param) {
                      var callback = callback_if_deferred(undefined);
                      return [
                              undefined,
                              callback,
                              p$1.state
                            ];
                    }));
    case /* Pending */2 :
        var callback = callback_if_deferred(undefined);
        return add_regular_callback_list_node(exn._0, {
                    TAG: /* Regular_callback_list_implicitly_removed_callback */1,
                    _0: callback
                  });
    
  }
}

function on_termination(p, f) {
  var p$1 = underlying(p);
  var p_callbacks = p$1.state;
  switch (p_callbacks.TAG | 0) {
    case /* Fulfilled */0 :
        return run_callback_or_defer_it(true, (function (param) {
                      return handle_with_async_exception_hook(f, undefined);
                    }), (function (param) {
                      var saved_storage = current_storage.contents;
                      var callback = function (_result) {
                        current_storage.contents = saved_storage;
                        return handle_with_async_exception_hook(f, undefined);
                      };
                      return [
                              undefined,
                              callback,
                              p$1.state
                            ];
                    }));
    case /* Rejected */1 :
        return run_callback_or_defer_it(true, (function (param) {
                      return handle_with_async_exception_hook(f, undefined);
                    }), (function (param) {
                      var saved_storage = current_storage.contents;
                      var callback = function (_result) {
                        current_storage.contents = saved_storage;
                        return handle_with_async_exception_hook(f, undefined);
                      };
                      return [
                              undefined,
                              callback,
                              p$1.state
                            ];
                    }));
    case /* Pending */2 :
        var saved_storage = current_storage.contents;
        var callback = function (_result) {
          current_storage.contents = saved_storage;
          return handle_with_async_exception_hook(f, undefined);
        };
        return add_regular_callback_list_node(p_callbacks._0, {
                    TAG: /* Regular_callback_list_implicitly_removed_callback */1,
                    _0: callback
                  });
    
  }
}

function on_any(p, f, g) {
  var p$1 = underlying(p);
  var callback_if_deferred = function (param) {
    var saved_storage = current_storage.contents;
    return function (result) {
      if (result.TAG === /* Fulfilled */0) {
        current_storage.contents = saved_storage;
        return handle_with_async_exception_hook(f, result._0);
      }
      current_storage.contents = saved_storage;
      return handle_with_async_exception_hook(g, result._0);
    };
  };
  var v = p$1.state;
  switch (v.TAG | 0) {
    case /* Fulfilled */0 :
        var v$1 = v._0;
        return run_callback_or_defer_it(true, (function (param) {
                      return handle_with_async_exception_hook(f, v$1);
                    }), (function (param) {
                      var callback = callback_if_deferred(undefined);
                      return [
                              undefined,
                              callback,
                              p$1.state
                            ];
                    }));
    case /* Rejected */1 :
        var exn = v._0;
        return run_callback_or_defer_it(true, (function (param) {
                      return handle_with_async_exception_hook(g, exn);
                    }), (function (param) {
                      var callback = callback_if_deferred(undefined);
                      return [
                              undefined,
                              callback,
                              p$1.state
                            ];
                    }));
    case /* Pending */2 :
        var callback = callback_if_deferred(undefined);
        return add_regular_callback_list_node(v._0, {
                    TAG: /* Regular_callback_list_implicitly_removed_callback */1,
                    _0: callback
                  });
    
  }
}

var Sequential_composition = {
  bind: bind,
  map: map,
  $$catch: $$catch,
  finalize: finalize,
  try_bind: try_bind,
  on_cancel: on_cancel,
  on_success: on_success,
  on_failure: on_failure,
  on_termination: on_termination,
  on_any: on_any,
  backtrace_bind: backtrace_bind,
  backtrace_catch: backtrace_catch,
  backtrace_finalize: backtrace_finalize,
  backtrace_try_bind: backtrace_try_bind
};

function wrap_in_cancelable(p) {
  var p_underlying = underlying(p);
  var match = p_underlying.state;
  switch (match.TAG | 0) {
    case /* Fulfilled */0 :
    case /* Rejected */1 :
        return p;
    case /* Pending */2 :
        var match$1 = task(undefined);
        var r = match$1[1];
        var p$prime = match$1[0];
        on_cancel(p$prime, (function (param) {
                return cancel(p);
              }));
        on_any(p, (function (param) {
                return wakeup(r, param);
              }), (function (param) {
                return wakeup_exn(r, param);
              }));
        return p$prime;
    
  }
}

function dont_wait(f, h) {
  var p;
  try {
    p = Curry._1(f, undefined);
  }
  catch (raw_exn){
    p = {
      state: {
        TAG: /* Rejected */1,
        _0: Caml_js_exceptions.internalToOCamlException(raw_exn)
      }
    };
  }
  var exn = underlying(p).state;
  switch (exn.TAG | 0) {
    case /* Fulfilled */0 :
        return ;
    case /* Rejected */1 :
        return Curry._1(h, exn._0);
    case /* Pending */2 :
        var callback = function (result) {
          if (result.TAG === /* Fulfilled */0) {
            return ;
          } else {
            return Curry._1(h, result._0);
          }
        };
        return add_regular_callback_list_node(exn._0, {
                    TAG: /* Regular_callback_list_implicitly_removed_callback */1,
                    _0: callback
                  });
    
  }
}

function async(f) {
  var p;
  try {
    p = Curry._1(f, undefined);
  }
  catch (raw_exn){
    p = {
      state: {
        TAG: /* Rejected */1,
        _0: Caml_js_exceptions.internalToOCamlException(raw_exn)
      }
    };
  }
  var exn = underlying(p).state;
  switch (exn.TAG | 0) {
    case /* Fulfilled */0 :
        return ;
    case /* Rejected */1 :
        return Curry._1(async_exception_hook.contents, exn._0);
    case /* Pending */2 :
        var callback = function (result) {
          if (result.TAG === /* Fulfilled */0) {
            return ;
          } else {
            return Curry._1(async_exception_hook.contents, result._0);
          }
        };
        return add_regular_callback_list_node(exn._0, {
                    TAG: /* Regular_callback_list_implicitly_removed_callback */1,
                    _0: callback
                  });
    
  }
}

function ignore_result(p) {
  var exn = underlying(p).state;
  switch (exn.TAG | 0) {
    case /* Fulfilled */0 :
        return ;
    case /* Rejected */1 :
        throw exn._0;
    case /* Pending */2 :
        var callback = function (result) {
          if (result.TAG === /* Fulfilled */0) {
            return ;
          } else {
            return Curry._1(async_exception_hook.contents, result._0);
          }
        };
        return add_regular_callback_list_node(exn._0, {
                    TAG: /* Regular_callback_list_implicitly_removed_callback */1,
                    _0: callback
                  });
    
  }
}

function join(ps) {
  var p$prime = new_pending({
        TAG: /* Propagate_cancel_to_several */1,
        _0: ps
      });
  var number_pending_in_ps = {
    contents: 0
  };
  var join_result = {
    contents: {
      TAG: /* Fulfilled */0,
      _0: undefined
    }
  };
  var callback = function (new_result) {
    if (new_result.TAG !== /* Fulfilled */0) {
      var match = join_result.contents;
      if (match.TAG === /* Fulfilled */0) {
        join_result.contents = new_result;
      }
      
    }
    number_pending_in_ps.contents = number_pending_in_ps.contents - 1 | 0;
    if (number_pending_in_ps.contents !== 0) {
      return ;
    }
    var p$prime$1 = underlying(p$prime);
    resolve(false, undefined, underlying(p$prime$1), join_result.contents);
    
  };
  var _ps = ps;
  while(true) {
    var ps$1 = _ps;
    if (!ps$1) {
      if (number_pending_in_ps.contents === 0) {
        return {
                state: join_result.contents
              };
      } else {
        return p$prime;
      }
    }
    var ps$2 = ps$1.tl;
    var p_callbacks = underlying(ps$1.hd).state;
    switch (p_callbacks.TAG | 0) {
      case /* Fulfilled */0 :
          _ps = ps$2;
          continue ;
      case /* Rejected */1 :
          var match = join_result.contents;
          if (match.TAG === /* Fulfilled */0) {
            join_result.contents = p_callbacks;
          }
          _ps = ps$2;
          continue ;
      case /* Pending */2 :
          number_pending_in_ps.contents = number_pending_in_ps.contents + 1 | 0;
          add_regular_callback_list_node(p_callbacks._0, {
                TAG: /* Regular_callback_list_implicitly_removed_callback */1,
                _0: callback
              });
          _ps = ps$2;
          continue ;
      
    }
  };
}

function both(p1, p2) {
  var pair = {
    x1: undefined,
    x2: undefined
  };
  var p1$prime = bind(p1, (function (v) {
          pair.x1 = Caml_option.some(v);
          return return_unit;
        }));
  var p2$prime = bind(p2, (function (v) {
          pair.x2 = Caml_option.some(v);
          return return_unit;
        }));
  return map((function (param) {
                var match = pair.x1;
                var match$1 = pair.x2;
                if (match !== undefined) {
                  if (match$1 !== undefined) {
                    return [
                            Caml_option.valFromOption(match),
                            Caml_option.valFromOption(match$1)
                          ];
                  }
                  throw {
                        RE_EXN_ID: "Assert_failure",
                        _1: [
                          "Lwt.re",
                          2242,
                          16
                        ],
                        Error: new Error()
                      };
                }
                throw {
                      RE_EXN_ID: "Assert_failure",
                      _1: [
                        "Lwt.re",
                        2242,
                        16
                      ],
                      Error: new Error()
                    };
              }), join({
                  hd: p1$prime,
                  tl: {
                    hd: p2$prime,
                    tl: /* [] */0
                  }
                }));
}

function all(ps) {
  if (!ps) {
    return return_nil;
  }
  var match = ps.tl;
  var x = ps.hd;
  if (!match) {
    return map((function (y) {
                  return {
                          hd: y,
                          tl: /* [] */0
                        };
                }), x);
  }
  if (!match.tl) {
    return map((function (param) {
                  return {
                          hd: param[0],
                          tl: {
                            hd: param[1],
                            tl: /* [] */0
                          }
                        };
                }), both(x, match.hd));
  }
  var vs = Caml_array.caml_make_vect(List.length(ps), undefined);
  return map((function (param) {
                var _i = vs.length - 1 | 0;
                var _acc = /* [] */0;
                while(true) {
                  var acc = _acc;
                  var i = _i;
                  if (i < 0) {
                    return acc;
                  }
                  var x = vs[i];
                  if (x !== undefined) {
                    _acc = {
                      hd: Caml_option.valFromOption(x),
                      tl: acc
                    };
                    _i = i - 1 | 0;
                    continue ;
                  }
                  throw {
                        RE_EXN_ID: "Assert_failure",
                        _1: [
                          "Lwt.re",
                          2270,
                          25
                        ],
                        Error: new Error()
                      };
                };
              }), join(List.mapi((function (index, p) {
                        return bind(p, (function (v) {
                                      Caml_array.set(vs, index, Caml_option.some(v));
                                      return return_unit;
                                    }));
                      }), ps)));
}

function count_resolved_promises_in(ps) {
  var accumulate = function (total, p) {
    var match = underlying(p).state;
    switch (match.TAG | 0) {
      case /* Fulfilled */0 :
      case /* Rejected */1 :
          return total + 1 | 0;
      case /* Pending */2 :
          return total;
      
    }
  };
  return List.fold_left(accumulate, 0, ps);
}

function nth_resolved(_ps, _n) {
  while(true) {
    var n = _n;
    var ps = _ps;
    if (ps) {
      var ps$1 = ps.tl;
      var p = ps.hd;
      var match = underlying(p).state;
      switch (match.TAG | 0) {
        case /* Fulfilled */0 :
        case /* Rejected */1 :
            break;
        case /* Pending */2 :
            _ps = ps$1;
            continue ;
        
      }
      if (n <= 0) {
        return p;
      }
      _n = n - 1 | 0;
      _ps = ps$1;
      continue ;
    }
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "Lwt.re",
            2297,
            12
          ],
          Error: new Error()
        };
  };
}

function nth_resolved_and_cancel_pending(_ps, _n) {
  while(true) {
    var n = _n;
    var ps = _ps;
    if (ps) {
      var ps$1 = ps.tl;
      var p = ps.hd;
      var match = underlying(p).state;
      switch (match.TAG | 0) {
        case /* Fulfilled */0 :
        case /* Rejected */1 :
            break;
        case /* Pending */2 :
            cancel(p);
            _ps = ps$1;
            continue ;
        
      }
      if (n <= 0) {
        List.iter(cancel, ps$1);
        return p;
      }
      _n = n - 1 | 0;
      _ps = ps$1;
      continue ;
    }
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "Lwt.re",
            2321,
            12
          ],
          Error: new Error()
        };
  };
}

var prng = {
  LAZY_DONE: false,
  VAL: (function () {
      return Random.State.make([]);
    })
};

function choose(ps) {
  if (ps === /* [] */0) {
    Pervasives.invalid_arg("Lwt.choose [] would return a promise that is pending forever");
  }
  var n = count_resolved_promises_in(ps);
  if (n !== 0) {
    if (n !== 1) {
      return nth_resolved(ps, Random.State.$$int(CamlinternalLazy.force(prng), n));
    } else {
      return nth_resolved(ps, 0);
    }
  }
  var p = new_pending({
        TAG: /* Propagate_cancel_to_several */1,
        _0: ps
      });
  var callback = function (result) {
    var p$1 = underlying(p);
    resolve(false, undefined, p$1, result);
    
  };
  add_explicitly_removable_callback_and_give_cell(ps, callback);
  return p;
}

function pick(ps) {
  if (ps === /* [] */0) {
    Pervasives.invalid_arg("Lwt.pick [] would return a promise that is pending forever");
  }
  var n = count_resolved_promises_in(ps);
  if (n !== 0) {
    if (n !== 1) {
      return nth_resolved_and_cancel_pending(ps, Random.State.$$int(CamlinternalLazy.force(prng), n));
    } else {
      return nth_resolved_and_cancel_pending(ps, 0);
    }
  }
  var p = new_pending({
        TAG: /* Propagate_cancel_to_several */1,
        _0: ps
      });
  var callback = function (result) {
    List.iter(cancel, ps);
    var p$1 = underlying(p);
    resolve(false, undefined, p$1, result);
    
  };
  add_explicitly_removable_callback_and_give_cell(ps, callback);
  return p;
}

function collect_fulfilled_promises_after_pending(_results, _ps) {
  while(true) {
    var ps = _ps;
    var results = _results;
    if (!ps) {
      return {
              TAG: /* Fulfilled */0,
              _0: List.rev(results)
            };
    }
    var ps$1 = ps.tl;
    var v = underlying(ps.hd).state;
    switch (v.TAG | 0) {
      case /* Fulfilled */0 :
          _ps = ps$1;
          _results = {
            hd: v._0,
            tl: results
          };
          continue ;
      case /* Rejected */1 :
          return v;
      case /* Pending */2 :
          _ps = ps$1;
          continue ;
      
    }
  };
}

function nchoose(ps) {
  if (ps === /* [] */0) {
    Pervasives.invalid_arg("Lwt.nchoose [] would return a promise that is pending forever");
  }
  var _ps$prime = ps;
  while(true) {
    var ps$prime = _ps$prime;
    if (ps$prime) {
      var ps$1 = ps$prime.tl;
      var v = underlying(ps$prime.hd).state;
      switch (v.TAG | 0) {
        case /* Fulfilled */0 :
            var _acc = {
              hd: v._0,
              tl: /* [] */0
            };
            var _ps = ps$1;
            while(true) {
              var ps$2 = _ps;
              var acc = _acc;
              if (ps$2) {
                var ps$3 = ps$2.tl;
                var v$1 = underlying(ps$2.hd).state;
                switch (v$1.TAG | 0) {
                  case /* Fulfilled */0 :
                      _ps = ps$3;
                      _acc = {
                        hd: v$1._0,
                        tl: acc
                      };
                      continue ;
                  case /* Rejected */1 :
                      return {
                              state: v$1
                            };
                  case /* Pending */2 :
                      _ps = ps$3;
                      continue ;
                  
                }
              } else {
                var v$2 = List.rev(acc);
                return {
                        state: {
                          TAG: /* Fulfilled */0,
                          _0: v$2
                        }
                      };
              }
            };
        case /* Rejected */1 :
            return {
                    state: v
                  };
        case /* Pending */2 :
            _ps$prime = ps$1;
            continue ;
        
      }
    } else {
      var p = new_pending({
            TAG: /* Propagate_cancel_to_several */1,
            _0: ps
          });
      var callback = (function(p){
      return function callback(_result) {
        var p$1 = underlying(p);
        var result = collect_fulfilled_promises_after_pending(/* [] */0, ps);
        resolve(false, undefined, p$1, result);
        
      }
      }(p));
      add_explicitly_removable_callback_and_give_cell(ps, callback);
      return p;
    }
  };
}

function npick(ps) {
  if (ps === /* [] */0) {
    Pervasives.invalid_arg("Lwt.npick [] would return a promise that is pending forever");
  }
  var _ps$prime = ps;
  while(true) {
    var ps$prime = _ps$prime;
    if (ps$prime) {
      var ps$prime$1 = ps$prime.tl;
      var v = underlying(ps$prime.hd).state;
      switch (v.TAG | 0) {
        case /* Fulfilled */0 :
            var _acc = {
              hd: v._0,
              tl: /* [] */0
            };
            var _ps$prime$1 = ps$prime$1;
            while(true) {
              var ps$prime$2 = _ps$prime$1;
              var acc = _acc;
              if (ps$prime$2) {
                var ps$prime$3 = ps$prime$2.tl;
                var v$1 = underlying(ps$prime$2.hd).state;
                switch (v$1.TAG | 0) {
                  case /* Fulfilled */0 :
                      _ps$prime$1 = ps$prime$3;
                      _acc = {
                        hd: v$1._0,
                        tl: acc
                      };
                      continue ;
                  case /* Rejected */1 :
                      List.iter(cancel, ps);
                      return {
                              state: v$1
                            };
                  case /* Pending */2 :
                      _ps$prime$1 = ps$prime$3;
                      continue ;
                  
                }
              } else {
                List.iter(cancel, ps);
                var v$2 = List.rev(acc);
                return {
                        state: {
                          TAG: /* Fulfilled */0,
                          _0: v$2
                        }
                      };
              }
            };
        case /* Rejected */1 :
            List.iter(cancel, ps);
            return {
                    state: v
                  };
        case /* Pending */2 :
            _ps$prime = ps$prime$1;
            continue ;
        
      }
    } else {
      var p = new_pending({
            TAG: /* Propagate_cancel_to_several */1,
            _0: ps
          });
      var callback = (function(p){
      return function callback(_result) {
        var p$1 = underlying(p);
        var result = collect_fulfilled_promises_after_pending(/* [] */0, ps);
        List.iter(cancel, ps);
        resolve(false, undefined, p$1, result);
        
      }
      }(p));
      add_explicitly_removable_callback_and_give_cell(ps, callback);
      return p;
    }
  };
}

function nchoose_split(ps) {
  if (ps === /* [] */0) {
    Pervasives.invalid_arg("Lwt.nchoose_split [] would return a promise that is pending forever");
  }
  var finish = function (to_resolve, _fulfilled, _pending, _ps) {
    while(true) {
      var ps = _ps;
      var pending = _pending;
      var fulfilled = _fulfilled;
      if (!ps) {
        return resolve(false, undefined, to_resolve, {
                    TAG: /* Fulfilled */0,
                    _0: [
                      List.rev(fulfilled),
                      List.rev(pending)
                    ]
                  });
      }
      var ps$1 = ps.tl;
      var p = ps.hd;
      var v = underlying(p).state;
      switch (v.TAG | 0) {
        case /* Fulfilled */0 :
            _ps = ps$1;
            _fulfilled = {
              hd: v._0,
              tl: fulfilled
            };
            continue ;
        case /* Rejected */1 :
            return resolve(false, undefined, to_resolve, v);
        case /* Pending */2 :
            _ps = ps$1;
            _pending = {
              hd: p,
              tl: pending
            };
            continue ;
        
      }
    };
  };
  var _pending_acc = /* [] */0;
  var _ps$prime = ps;
  while(true) {
    var ps$prime = _ps$prime;
    var pending_acc = _pending_acc;
    if (ps$prime) {
      var ps$prime$1 = ps$prime.tl;
      var p = ps$prime.hd;
      var v = underlying(p).state;
      switch (v.TAG | 0) {
        case /* Fulfilled */0 :
            var _results = {
              hd: v._0,
              tl: /* [] */0
            };
            var _pending = pending_acc;
            var _ps = ps$prime$1;
            while(true) {
              var ps$1 = _ps;
              var pending = _pending;
              var results = _results;
              if (ps$1) {
                var ps$2 = ps$1.tl;
                var p$1 = ps$1.hd;
                var v$1 = underlying(p$1).state;
                switch (v$1.TAG | 0) {
                  case /* Fulfilled */0 :
                      _ps = ps$2;
                      _results = {
                        hd: v$1._0,
                        tl: results
                      };
                      continue ;
                  case /* Rejected */1 :
                      return {
                              state: v$1
                            };
                  case /* Pending */2 :
                      _ps = ps$2;
                      _pending = {
                        hd: p$1,
                        tl: pending
                      };
                      continue ;
                  
                }
              } else {
                var v_0 = List.rev(results);
                var v$2 = [
                  v_0,
                  pending
                ];
                return {
                        state: {
                          TAG: /* Fulfilled */0,
                          _0: v$2
                        }
                      };
              }
            };
        case /* Rejected */1 :
            return {
                    state: v
                  };
        case /* Pending */2 :
            _ps$prime = ps$prime$1;
            _pending_acc = {
              hd: p,
              tl: pending_acc
            };
            continue ;
        
      }
    } else {
      var p$2 = new_pending({
            TAG: /* Propagate_cancel_to_several */1,
            _0: ps
          });
      var callback = (function(p$2){
      return function callback(_result) {
        var p$3 = underlying(p$2);
        finish(p$3, /* [] */0, /* [] */0, ps);
        
      }
      }(p$2));
      add_explicitly_removable_callback_and_give_cell(ps, callback);
      return p$2;
    }
  };
}

var Concurrent_composition = {
  dont_wait: dont_wait,
  async: async,
  ignore_result: ignore_result,
  both: both,
  join: join,
  all: all,
  choose: choose,
  pick: pick,
  nchoose: nchoose,
  npick: npick,
  nchoose_split: nchoose_split
};

function state(p) {
  var v = underlying(p).state;
  switch (v.TAG | 0) {
    case /* Fulfilled */0 :
        return {
                TAG: /* Return */0,
                _0: v._0
              };
    case /* Rejected */1 :
        return {
                TAG: /* Fail */1,
                _0: v._0
              };
    case /* Pending */2 :
        return /* Sleep */0;
    
  }
}

function debug_state_is(expected_state, p) {
  var v = Caml_obj.caml_equal(state(p), expected_state);
  return {
          state: {
            TAG: /* Fulfilled */0,
            _0: v
          }
        };
}

function is_sleeping(p) {
  var match = underlying(p).state;
  switch (match.TAG | 0) {
    case /* Fulfilled */0 :
    case /* Rejected */1 :
        return false;
    case /* Pending */2 :
        return true;
    
  }
}

function poll(p) {
  var e = underlying(p).state;
  switch (e.TAG | 0) {
    case /* Fulfilled */0 :
        return Caml_option.some(e._0);
    case /* Rejected */1 :
        throw e._0;
    case /* Pending */2 :
        return ;
    
  }
}

function apply(f, x) {
  try {
    return Curry._1(f, x);
  }
  catch (raw_exn){
    return {
            state: {
              TAG: /* Rejected */1,
              _0: Caml_js_exceptions.internalToOCamlException(raw_exn)
            }
          };
  }
}

function wrap(f) {
  try {
    var v = Curry._1(f, undefined);
    return {
            state: {
              TAG: /* Fulfilled */0,
              _0: v
            }
          };
  }
  catch (raw_exn){
    return {
            state: {
              TAG: /* Rejected */1,
              _0: Caml_js_exceptions.internalToOCamlException(raw_exn)
            }
          };
  }
}

function wrap1(f, x1) {
  try {
    var v = Curry._1(f, x1);
    return {
            state: {
              TAG: /* Fulfilled */0,
              _0: v
            }
          };
  }
  catch (raw_exn){
    return {
            state: {
              TAG: /* Rejected */1,
              _0: Caml_js_exceptions.internalToOCamlException(raw_exn)
            }
          };
  }
}

function wrap2(f, x1, x2) {
  try {
    var v = Curry._2(f, x1, x2);
    return {
            state: {
              TAG: /* Fulfilled */0,
              _0: v
            }
          };
  }
  catch (raw_exn){
    return {
            state: {
              TAG: /* Rejected */1,
              _0: Caml_js_exceptions.internalToOCamlException(raw_exn)
            }
          };
  }
}

function wrap3(f, x1, x2, x3) {
  try {
    var v = Curry._3(f, x1, x2, x3);
    return {
            state: {
              TAG: /* Fulfilled */0,
              _0: v
            }
          };
  }
  catch (raw_exn){
    return {
            state: {
              TAG: /* Rejected */1,
              _0: Caml_js_exceptions.internalToOCamlException(raw_exn)
            }
          };
  }
}

function wrap4(f, x1, x2, x3, x4) {
  try {
    var v = Curry._4(f, x1, x2, x3, x4);
    return {
            state: {
              TAG: /* Fulfilled */0,
              _0: v
            }
          };
  }
  catch (raw_exn){
    return {
            state: {
              TAG: /* Rejected */1,
              _0: Caml_js_exceptions.internalToOCamlException(raw_exn)
            }
          };
  }
}

function wrap5(f, x1, x2, x3, x4, x5) {
  try {
    var v = Curry._5(f, x1, x2, x3, x4, x5);
    return {
            state: {
              TAG: /* Fulfilled */0,
              _0: v
            }
          };
  }
  catch (raw_exn){
    return {
            state: {
              TAG: /* Rejected */1,
              _0: Caml_js_exceptions.internalToOCamlException(raw_exn)
            }
          };
  }
}

function wrap6(f, x1, x2, x3, x4, x5, x6) {
  try {
    var v = Curry._6(f, x1, x2, x3, x4, x5, x6);
    return {
            state: {
              TAG: /* Fulfilled */0,
              _0: v
            }
          };
  }
  catch (raw_exn){
    return {
            state: {
              TAG: /* Rejected */1,
              _0: Caml_js_exceptions.internalToOCamlException(raw_exn)
            }
          };
  }
}

function wrap7(f, x1, x2, x3, x4, x5, x6, x7) {
  try {
    var v = Curry._7(f, x1, x2, x3, x4, x5, x6, x7);
    return {
            state: {
              TAG: /* Fulfilled */0,
              _0: v
            }
          };
  }
  catch (raw_exn){
    return {
            state: {
              TAG: /* Rejected */1,
              _0: Caml_js_exceptions.internalToOCamlException(raw_exn)
            }
          };
  }
}

var pause_hook = {
  contents: (function (prim) {
      
    })
};

var paused = LwtDllist$Repacked.create(undefined);

var paused_count = {
  contents: 0
};

function pause(param) {
  var p = add_task_r(paused);
  paused_count.contents = paused_count.contents + 1 | 0;
  Curry._1(pause_hook.contents, paused_count.contents);
  return p;
}

function wakeup_paused(param) {
  if (LwtDllist$Repacked.is_empty(paused)) {
    paused_count.contents = 0;
    return ;
  }
  var tmp = LwtDllist$Repacked.create(undefined);
  LwtDllist$Repacked.transfer_r(paused, tmp);
  paused_count.contents = 0;
  return LwtDllist$Repacked.iter_l((function (r) {
                return wakeup(r, undefined);
              }), tmp);
}

function register_pause_notifier(f) {
  pause_hook.contents = f;
  
}

function abandon_paused(param) {
  LwtDllist$Repacked.clear(paused);
  paused_count.contents = 0;
  
}

function paused_count$1(param) {
  return paused_count.contents;
}

var Miscellaneous = {
  state: state,
  is_sleeping: is_sleeping,
  debug_state_is: debug_state_is,
  apply: apply,
  wrap: wrap,
  wrap1: wrap1,
  wrap2: wrap2,
  wrap3: wrap3,
  wrap4: wrap4,
  wrap5: wrap5,
  wrap6: wrap6,
  wrap7: wrap7,
  pause: pause,
  wakeup_paused: wakeup_paused,
  paused_count: paused_count$1,
  register_pause_notifier: register_pause_notifier,
  abandon_paused: abandon_paused,
  poll: poll
};

function map$1(t, f) {
  return map(f, t);
}

var bind$1 = bind;

var Open_on_rhs = {};

var Let_syntax = {
  $$return: $$return,
  map: map$1,
  bind: bind$1,
  both: both,
  Open_on_rhs: Open_on_rhs
};

var Let_syntax$1 = {
  Let_syntax: Let_syntax
};

function $eq$less$less(f, p) {
  return bind(p, f);
}

function $great$pipe$eq(p, f) {
  return map(f, p);
}

function $less$amp$great(p, p$prime) {
  return join({
              hd: p,
              tl: {
                hd: p$prime,
                tl: /* [] */0
              }
            });
}

function $less$question$great(p, p$prime) {
  return choose({
              hd: p,
              tl: {
                hd: p$prime,
                tl: /* [] */0
              }
            });
}

var Infix = {
  $great$great$eq: bind,
  $eq$less$less: $eq$less$less,
  $great$pipe$eq: $great$pipe$eq,
  $eq$pipe$less: map,
  $less$amp$great: $less$amp$great,
  $less$question$great: $less$question$great,
  Let_syntax: Let_syntax
};

function let$plusawait(v, f) {
  return map(f, v);
}

var Syntax = {
  $$await: $$return,
  let$dotawait: bind,
  and$dotawait: both,
  let$plusawait: let$plusawait
};

function make_value(v) {
  return {
          TAG: /* Ok */0,
          _0: v
        };
}

function make_error(exn) {
  return {
          TAG: /* Error */1,
          _0: exn
        };
}

var Lwt_result_type = {
  make_value: make_value,
  make_error: make_error
};

var Lwt_sequence;

var $great$great$eq = bind;

var $eq$pipe$less = map;

exports.LwtSeq = LwtSeq;
exports.Lwt_sequence = Lwt_sequence;
exports.Storage_map = Storage_map;
exports.Main_internal_types = Main_internal_types;
exports.Public_types = Public_types;
exports.Result = Result;
exports.to_public_promise = to_public_promise;
exports.to_public_resolver = to_public_resolver;
exports.to_internal_promise = to_internal_promise;
exports.to_internal_resolver = to_internal_resolver;
exports.state_of_result = state_of_result;
exports.Basic_helpers = Basic_helpers;
exports.Sequence_associated_storage = Sequence_associated_storage;
exports.new_key = new_key;
exports.get = get$1;
exports.with_value = with_value;
exports.current_storage = current_storage;
exports.Pending_callbacks = Pending_callbacks;
exports.Resolution_loop = Resolution_loop;
exports.resolve = resolve;
exports.run_callbacks_or_defer_them = run_callbacks_or_defer_them;
exports.run_callback_or_defer_it = run_callback_or_defer_it;
exports.handle_with_async_exception_hook = handle_with_async_exception_hook;
exports.abandon_wakeups = abandon_wakeups;
exports.Canceled = Canceled;
exports.async_exception_hook = async_exception_hook;
exports.Resolving = Resolving;
exports.wakeup_later_result = wakeup_later_result;
exports.wakeup_later = wakeup_later;
exports.wakeup_later_exn = wakeup_later_exn;
exports.wakeup_result = wakeup_result;
exports.wakeup = wakeup;
exports.wakeup_exn = wakeup_exn;
exports.cancel = cancel;
exports.Trivial_promises = Trivial_promises;
exports.$$return = $$return;
exports.fail = fail;
exports.of_result = of_result;
exports.return_unit = return_unit;
exports.return_true = return_true;
exports.return_false = return_false;
exports.return_none = return_none;
exports.return_some = return_some;
exports.return_ok = return_ok;
exports.return_error = return_error;
exports.return_nil = return_nil;
exports.fail_with = fail_with;
exports.fail_invalid_arg = fail_invalid_arg;
exports.Pending_promises = Pending_promises;
exports.new_pending = new_pending;
exports.propagate_cancel_to_several = propagate_cancel_to_several;
exports.wait = wait;
exports.task = task;
exports.waiter_of_wakener = waiter_of_wakener;
exports.add_task_r = add_task_r;
exports.add_task_l = add_task_l;
exports.$$protected = $$protected;
exports.no_cancel = no_cancel;
exports.Sequential_composition = Sequential_composition;
exports.bind = bind;
exports.map = map;
exports.$$catch = $$catch;
exports.finalize = finalize;
exports.try_bind = try_bind;
exports.on_cancel = on_cancel;
exports.on_success = on_success;
exports.on_failure = on_failure;
exports.on_termination = on_termination;
exports.on_any = on_any;
exports.backtrace_bind = backtrace_bind;
exports.backtrace_catch = backtrace_catch;
exports.backtrace_finalize = backtrace_finalize;
exports.backtrace_try_bind = backtrace_try_bind;
exports.wrap_in_cancelable = wrap_in_cancelable;
exports.Concurrent_composition = Concurrent_composition;
exports.dont_wait = dont_wait;
exports.async = async;
exports.ignore_result = ignore_result;
exports.both = both;
exports.join = join;
exports.all = all;
exports.choose = choose;
exports.pick = pick;
exports.nchoose = nchoose;
exports.npick = npick;
exports.nchoose_split = nchoose_split;
exports.Miscellaneous = Miscellaneous;
exports.state = state;
exports.is_sleeping = is_sleeping;
exports.debug_state_is = debug_state_is;
exports.apply = apply;
exports.wrap = wrap;
exports.wrap1 = wrap1;
exports.wrap2 = wrap2;
exports.wrap3 = wrap3;
exports.wrap4 = wrap4;
exports.wrap5 = wrap5;
exports.wrap6 = wrap6;
exports.wrap7 = wrap7;
exports.pause = pause;
exports.wakeup_paused = wakeup_paused;
exports.paused_count = paused_count$1;
exports.register_pause_notifier = register_pause_notifier;
exports.abandon_paused = abandon_paused;
exports.poll = poll;
exports.Let_syntax = Let_syntax$1;
exports.Infix = Infix;
exports.$great$great$eq = $great$great$eq;
exports.$eq$less$less = $eq$less$less;
exports.$great$pipe$eq = $great$pipe$eq;
exports.$eq$pipe$less = $eq$pipe$less;
exports.$less$amp$great = $less$amp$great;
exports.$less$question$great = $less$question$great;
exports.Syntax = Syntax;
exports.Lwt_result_type = Lwt_result_type;
exports.make_value = make_value;
exports.make_error = make_error;
/* Storage_map Not a pure module */
